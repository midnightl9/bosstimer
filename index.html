<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Boss Timers</title>
  <style>
    :root{
      --bg0:#050608;
      --bg1:#0a0c10;
      --text:#e8e8ea;
      --muted:#9aa0a6;

      --accentRed:#ff3b3b;
      --accentGold:#caa24a;
      --accentGold2:#f2d38a;
      --accentGreen:#34d399;

      --shadow: 0 20px 60px rgba(0,0,0,.55);
      --radius: 14px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 700px at 10% 0%, rgba(255,59,59,.12), transparent 60%),
        radial-gradient(900px 600px at 90% 10%, rgba(202,162,74,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--text);
      padding:24px;
      padding-top: 120px; /* space for banner */
    }

    h2{ margin:0 0 14px 0; letter-spacing:.2px; }

    .wrap{ max-width: 1600px; margin: 0 auto; }

    .section{
      margin-bottom: 28px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,.06);
    }

    .toolbar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom: 14px;
    }

    /* Inputs/Buttons */
    .input, .btn{
      height: 34px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 0 10px;
      outline:none;
      width: 100%;
      max-width: 100%;
    }
    .input{ min-width: 150px; }
    .btn{
      cursor:pointer;
      font-weight: 600;
      letter-spacing: .2px;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      background: rgba(255,255,255,.06);
    }
    .btn:hover{
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.18);
    }
    .btn:active{ transform: translateY(1px) }
    .btn.primary{
      background: rgba(120,170,255,.18);
      border-color: rgba(120,170,255,.35);
    }

    /* Grid */
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 14px;
      align-items: stretch;
    }

    /* Cards */
    .card{
      position: relative;
      border-radius: var(--radius);
      padding: 12px;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      box-shadow: var(--shadow);

      display:flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;

      border: 2px solid rgba(202,162,74,.85); /* GOLD OUTER BORDER */
    }

    .card::before{
      content:"";
      position:absolute;
      inset: 8px;
      border-radius: 10px;
      border: 1px solid rgba(242,211,138,.25);
      pointer-events:none;
      opacity:.9;
    }

    .card > *{ position: relative; z-index: 1; }

    .topRow{
      display:flex;
      justify-content: space-between;
      align-items:flex-start;
      gap: 10px;
      margin-bottom: 2px;
    }

    .bossName{
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .7px;
      text-transform: uppercase;
      line-height: 1.1;
      max-width: 100%;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .pill{
      font-size: 11px;
      color: rgba(255,255,255,.85);
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      padding: 3px 8px;
      border-radius: 999px;
      white-space:nowrap;
      user-select:none;
    }

    .timer{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-weight: 900;
      font-size: 20px;
      letter-spacing: .4px;
      margin: 0;
    }
    .timer.red{ color: var(--accentRed); }
    .timer.green{ color: var(--accentGreen); }

    .nextLine{
      font-size: 11px;
      color: rgba(255,255,255,.8);
      margin: 0 0 6px 0;
      letter-spacing: .2px;
    }
    .nextLine span{
      color: var(--accentGold2);
      font-weight: 700;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 44px;
      gap: 8px;
      align-items:center;
      margin: 0;
      min-width: 0;
    }

    .dateRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      min-width: 0;
    }
    .dateRow .input{ min-width: 0; }

    .miniBtn{
      width: 44px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid rgba(202,162,74,.55);
      background: rgba(202,162,74,.10);
      color: rgba(255,255,255,.92);
      font-weight: 800;
      letter-spacing: .2px;
      cursor:pointer;
    }
    .miniBtn:hover{
      background: rgba(202,162,74,.14);
      border-color: rgba(202,162,74,.80);
    }

    .btnStack{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 2px;
    }

    .stackBtn{
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(242,211,138,.35);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.92);
      font-weight: 800;
      cursor:pointer;
      text-transform: none;
      width: 100%;
      max-width: 100%;
    }
    .stackBtn:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(242,211,138,.55);
    }

    .footer{
      font-size: 10px;
      color: rgba(255,255,255,.55);
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap:wrap;
      padding-top: 4px;
      margin-top: 2px;
    }

    .muted{ color: var(--muted); }

    .hint{
      font-size: 12px;
      color: rgba(255,255,255,.65);
      margin-top: -6px;
      margin-bottom: 10px;
    }

    .sectionTitle{
      display:flex;
      flex-direction:column;
      gap:4px;
      margin-bottom: 10px;
    }
    .sectionTitle h2{
      font-size: 18px;
      font-weight: 900;
    }

    /* ===== NEXT BOSS BANNER (top center, gold) ===== */
    .nextBossBanner{
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;

      width: min(720px, calc(100vw - 28px));
      border-radius: 999px;
      padding: 16px 18px;

      border: 1px solid rgba(242,211,138,.55);
      background:
        radial-gradient(900px 300px at 20% 20%, rgba(202,162,74,.22), transparent 60%),
        radial-gradient(700px 260px at 90% 10%, rgba(242,211,138,.18), transparent 55%),
        linear-gradient(90deg, rgba(202,162,74,.18), rgba(242,211,138,.14));
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      backdrop-filter: blur(8px);

      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 14px;
    }

    .nextBossLeft{
      display:flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }
    .nextBossTitle{
      font-size: 34px;
      font-weight: 900;
      letter-spacing: .2px;
      line-height: 1.05;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nextBossSub{
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap: wrap;
    }

    .nbPill{
      display:flex;
      align-items:center;
      gap: 10px;
      border-radius: 999px;
      padding: 10px 14px;
      border: 1px solid rgba(242,211,138,.28);
      background: rgba(0,0,0,.28);
      color: rgba(255,255,255,.95);
      font-weight: 900;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      letter-spacing: .2px;
      white-space: nowrap;
    }
    .nbPill strong{
      font-family: inherit;
      font-weight: 900;
    }
    .nbCountdown{
      border-color: rgba(52,211,153,.45);
      background: rgba(0,0,0,.22);
      color: var(--accentGreen);
    }

    .hidden{ display:none !important; }

    @media (max-width: 520px){
      body{ padding-top: 140px; }
      .nextBossTitle{ font-size: 24px; }
      .nbPill{ padding: 8px 12px; }
    }

    @media (max-width: 420px){
      .controls{ grid-template-columns: 1fr 40px; }
      .miniBtn{ width: 40px; }
    }
  </style>
</head>

<body>

  <!-- Next Boss banner -->
  <div id="nextBossBanner" class="nextBossBanner hidden" aria-live="polite">
    <div class="nextBossLeft">
      <div class="nextBossTitle">Next Boss: <span id="nbName">‚Äî</span></div>
      <div class="nextBossSub">
        <div class="nbPill" title="Next spawn time (PH time)">
          üïí <strong id="nbClock">--:-- --</strong>
        </div>
        <div class="nbPill nbCountdown" title="Time remaining">
          ‚è≥ <strong id="nbCountdown">00:00:00</strong>
        </div>
      </div>
    </div>
  </div>

<div class="wrap">

  <!-- MANUAL -->
  <div class="section" id="manualSection">
    <div class="sectionTitle">
      <h2>Manual Boss Timers</h2>
      <div class="toolbar">
        <input class="input" id="manualName" placeholder="Boss Name" />
        <input class="input" id="manualHours" placeholder="Hours" type="number" step="0.01" min="0" />
        <button class="btn primary" id="addManual">Add Manual Timer</button>
        <button class="btn" id="resetAll">Reset All</button>
      </div>
      <div class="hint">Manual bosses: set a respawn in hours. Use <span class="muted">Killed Now</span> to start the countdown.</div>
    </div>

    <div class="grid" id="manualGrid"></div>
  </div>

  <!-- SCHEDULED -->
  <div class="section" id="scheduledSection">
    <div class="sectionTitle">
      <h2>Scheduled Bosses</h2>
      <div class="toolbar">
        <input class="input" id="schedName" placeholder="Boss Name" />
        <input class="input" id="schedRule" placeholder="Schedule e.g. mon 12:30, tue 19:00" />
        <button class="btn primary" id="addScheduled">Add Scheduled Boss</button>
      </div>
      <div class="hint">
        Scheduled bosses: write times like <span class="muted">mon 19:00, wed 11:30, thu 11:30</span>. 24-hour time recommended.
      </div>
    </div>

    <div class="grid" id="scheduledGrid"></div>
  </div>

</div>

<script>
/* ===========================
   PH TIME helpers
=========================== */
const PH_TZ = "Asia/Manila";

const phClockFmt = new Intl.DateTimeFormat("en-US", {
  timeZone: PH_TZ, hour: "2-digit", minute: "2-digit", hour12: true
});

const phShortFmt = new Intl.DateTimeFormat("en-US", {
  timeZone: PH_TZ,
  year: "numeric", month: "numeric", day: "numeric",
  hour: "numeric", minute: "2-digit", second: "2-digit",
  hour12: true
});

function formatClockPH(dt){
  return phClockFmt.format(dt);
}
function formatShortPH(dt){
  return phShortFmt.format(dt);
}

/* ---------------------------
   Storage + defaults
----------------------------*/
const LS_KEY = "bossTimers_v1";

const DEFAULT_MANUAL = [
  { name:"Baron Braudmore", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:45:01" },
  { name:"Gareth", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:45:52" },
  { name:"Lady Dalia", hours: 6, lastKill: null, lastRestart: null },
  { name:"Ego", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:35:09" },
  { name:"Livera", hours: 6, lastKill: null, lastRestart: null },
  { name:"Araneo", hours: 6, lastKill: null, lastRestart: null },
  { name:"Undomiel", hours: 6, lastKill: null, lastRestart: null },
  { name:"Amentis", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:44:17" },
  { name:"General Aquleus", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:44:35" },
  { name:"Larba", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:50:28" },
  { name:"Shuliar", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:50:41" },
  { name:"Catena", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:51:06" },
  { name:"Venatus", hours: 6, lastKill: null, lastRestart: "2026-01-13T19:34:08" },
  { name:"Viorent", hours: 6, lastKill: null, lastRestart: "2026-01-13T19:34:24" },
  { name:"Titore", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:42:46" },
  { name:"Duplican", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:46:57" },
  { name:"Metus", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:47:15" },
  { name:"Wannitas", hours: 6, lastKill: null, lastRestart: "2026-01-13T17:47:29" },
  { name:"Secreta", hours: 6, lastKill: null, lastRestart: "2026-01-13T18:47:49" },
  { name:"Ordo", hours: 6, lastKill: null, lastRestart: "2026-01-13T18:47:53" },
  { name:"Asta", hours: 6, lastKill: null, lastRestart: "2026-01-13T18:48:00" },
  { name:"Supore", hours: 72, lastKill: "2026-02-20T01:57:18", lastRestart: "2026-02-20T01:57:18" }
];

const DEFAULT_SCHEDULED = [
  { name:"Roderick", rule:"fri 19:00" },
  { name:"Milavy", rule:"sat 15:00" },
  { name:"Ringor", rule:"sat 17:00" },
  { name:"Saphirus", rule:"sun 17:00, tue 17:00" },
  { name:"Auraq", rule:"sun 21:00, wed 21:00" },
  { name:"Climantis", rule:"mon 11:30, thu 11:30" },
  { name:"Thymele", rule:"mon 19:00, wed 19:00" },
  { name:"Neutro", rule:"tue 19:00, thu 19:00" }
];

function uid(){
  if (window.crypto?.randomUUID) return crypto.randomUUID();
  return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}

function ensureIds(arr){
  return arr.map(x => (x && x.id) ? x : ({ ...x, id: uid() }));
}

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw){
      return { manual: ensureIds(DEFAULT_MANUAL), scheduled: ensureIds(DEFAULT_SCHEDULED) };
    }
    const parsed = JSON.parse(raw);
    const manual = ensureIds(Array.isArray(parsed.manual) ? parsed.manual : DEFAULT_MANUAL);
    const scheduled = ensureIds(Array.isArray(parsed.scheduled) ? parsed.scheduled : DEFAULT_SCHEDULED);
    return { manual, scheduled };
  }catch{
    return { manual: ensureIds(DEFAULT_MANUAL), scheduled: ensureIds(DEFAULT_SCHEDULED) };
  }
}

let state = loadState();

function saveState(){
  localStorage.setItem(LS_KEY, JSON.stringify(state));
}

function resetAll(){
  state.manual = ensureIds(structuredClone(DEFAULT_MANUAL));
  state.scheduled = ensureIds(structuredClone(DEFAULT_SCHEDULED));
  saveState();
  renderAll();
}

/* ---------------------------
   Date helpers
----------------------------*/
const DOW = { sun:0, mon:1, tue:2, wed:3, thu:4, fri:5, sat:6 };

function pad(n){ return String(n).padStart(2,"0"); }

function msToClock(ms){
  const neg = ms < 0;
  ms = Math.abs(ms);

  const sec = Math.floor(ms / 1000);
  const days = Math.floor(sec / 86400);
  const hours = Math.floor((sec % 86400)/3600);
  const mins = Math.floor((sec % 3600)/60);
  const secs = sec % 60;

  const out = (days > 0)
    ? `${days}:${pad(hours)}:${pad(mins)}:${pad(secs)}`
    : `${pad(hours)}:${pad(mins)}:${pad(secs)}`;

  return neg ? `-${out}` : out;
}

function parseScheduleRule(ruleStr){
  const parts = ruleStr.split(",").map(s => s.trim()).filter(Boolean);
  const out = [];
  for(const p of parts){
    const m = p.match(/^([a-z]{3})\s+(\d{1,2}):(\d{2})$/i);
    if(!m) continue;
    const dowKey = m[1].toLowerCase();
    if(!(dowKey in DOW)) continue;
    const hour = Math.max(0, Math.min(23, parseInt(m[2],10)));
    const min = Math.max(0, Math.min(59, parseInt(m[3],10)));
    out.push({ dow: DOW[dowKey], hour, min });
  }
  return out;
}

function nextOccurrenceFromRule(ruleStr, fromDate = new Date()){
  const rules = parseScheduleRule(ruleStr);
  if(rules.length === 0) return null;

  const now = new Date(fromDate);
  let best = null;

  for(const r of rules){
    const candidate = new Date(now);
    candidate.setSeconds(0,0);
    candidate.setHours(r.hour, r.min, 0, 0);

    const curDow = now.getDay();
    let addDays = (r.dow - curDow + 7) % 7;

    if(addDays === 0 && candidate <= now) addDays = 7;
    candidate.setDate(candidate.getDate() + addDays);

    if(!best || candidate < best) best = candidate;
  }
  return best;
}

/* ---------------------------
   Manual logic
----------------------------*/
function findManualIndexById(id){ return state.manual.findIndex(b => b.id === id); }
function findScheduledIndexById(id){ return state.scheduled.findIndex(b => b.id === id); }

function getManualNextTime(b){
  if(!b?.lastKill) return null;
  const kill = new Date(b.lastKill);
  return new Date(kill.getTime() + (b.hours * 3600 * 1000));
}

/* ---------------------------
   Sorting helpers (LOWEST -> HIGHEST time remaining)
----------------------------*/
function getManualDiffMs(b, now){
  const next = getManualNextTime(b);
  if(!next) return Number.POSITIVE_INFINITY;
  return next - now;
}
function getScheduledDiffMs(b, now){
  const next = nextOccurrenceFromRule(b.rule, now);
  if(!next) return Number.POSITIVE_INFINITY;
  return next - now;
}

/* ---------------------------
   Auto-reset manual when expired (after 30s)
----------------------------*/
const pendingAutoResets = new Map(); // id -> timeoutId

function scheduleAutoResetIfExpired(manualBoss, diffMs){
  if(!manualBoss?.id) return;

  // Only if we have a kill time (i.e. it's a real countdown)
  if(!manualBoss.lastKill) return;

  // Expired or at 0
  if(diffMs <= 0){
    if(pendingAutoResets.has(manualBoss.id)) return;

    const t = setTimeout(() => {
      pendingAutoResets.delete(manualBoss.id);

      const idx = findManualIndexById(manualBoss.id);
      if(idx < 0) return;

      const b = state.manual[idx];
      const next = getManualNextTime(b);
      const stillExpired = next ? (next - new Date()) <= 0 : false;

      if(stillExpired){
        const now = new Date();
        state.manual[idx].lastKill = now.toISOString();
        state.manual[idx].lastRestart = now.toISOString();
        saveState();
        renderAll();
      }
    }, 30000);

    pendingAutoResets.set(manualBoss.id, t);
  } else {
    // If user updated the timer back to running, cancel any pending reset
    const t = pendingAutoResets.get(manualBoss.id);
    if(t){
      clearTimeout(t);
      pendingAutoResets.delete(manualBoss.id);
    }
  }
}

/* ---------------------------
   UI banner: Next Boss (soonest upcoming, diff>0)
----------------------------*/
const bannerEl = document.getElementById("nextBossBanner");
const nbNameEl = document.getElementById("nbName");
const nbClockEl = document.getElementById("nbClock");
const nbCountdownEl = document.getElementById("nbCountdown");

function updateNextBossBanner(now){
  let best = null; // {name, nextDate, diffMs}

  // Manual bosses
  for(const b of state.manual){
    const next = getManualNextTime(b);
    if(!next) continue;
    const diff = next - now;
    if(diff <= 0) continue; // only bosses that will respawn (upcoming)
    if(!best || diff < best.diffMs){
      best = { name: b.name, nextDate: next, diffMs: diff };
    }
  }

  // Scheduled bosses
  for(const b of state.scheduled){
    const next = nextOccurrenceFromRule(b.rule, now);
    if(!next) continue;
    const diff = next - now;
    if(diff <= 0) continue;
    if(!best || diff < best.diffMs){
      best = { name: b.name, nextDate: next, diffMs: diff };
    }
  }

  if(!best){
    bannerEl.classList.add("hidden");
    return;
  }

  bannerEl.classList.remove("hidden");
  nbNameEl.textContent = best.name;
  nbClockEl.textContent = formatClockPH(best.nextDate);
  nbCountdownEl.textContent = msToClock(best.diffMs);
}

/* ---------------------------
   App state wiring
----------------------------*/
const manualGrid = document.getElementById("manualGrid");
const scheduledGrid = document.getElementById("scheduledGrid");

document.getElementById("addManual").addEventListener("click", () => {
  const name = document.getElementById("manualName").value.trim();
  const hoursStr = document.getElementById("manualHours").value.trim();
  const hours = Number(hoursStr);

  if(!name || !Number.isFinite(hours) || hours <= 0) return;

  state.manual.unshift({
    id: uid(),
    name,
    hours,
    lastKill: null,
    lastRestart: new Date().toISOString()
  });

  document.getElementById("manualName").value = "";
  document.getElementById("manualHours").value = "";
  saveState();
  renderAll();
});

document.getElementById("addScheduled").addEventListener("click", () => {
  const name = document.getElementById("schedName").value.trim();
  const rule = document.getElementById("schedRule").value.trim();
  if(!name || !rule) return;

  state.scheduled.unshift({ id: uid(), name, rule });
  document.getElementById("schedName").value = "";
  document.getElementById("schedRule").value = "";
  saveState();
  renderAll();
});

document.getElementById("resetAll").addEventListener("click", () => {
  if(confirm("Reset everything to defaults?")) resetAll();
});

function manualKilledNow(id){
  const idx = findManualIndexById(id);
  if(idx < 0) return;
  const now = new Date();
  state.manual[idx].lastKill = now.toISOString();
  state.manual[idx].lastRestart = now.toISOString();
  saveState();
  renderAll();
}

function manualSetKill(id){
  const idx = findManualIndexById(id);
  if(idx < 0) return;

  const dateEl = document.getElementById(`mk_date_${id}`);
  const timeEl = document.getElementById(`mk_time_${id}`);
  const dateVal = dateEl?.value;
  const timeVal = timeEl?.value;
  if(!dateVal || !timeVal) return;

  const dt = new Date(`${dateVal}T${timeVal}:00`);
  if(Number.isNaN(dt.getTime())) return;

  state.manual[idx].lastKill = dt.toISOString();
  state.manual[idx].lastRestart = new Date().toISOString();
  saveState();
  renderAll();
}

function manualSetNext(id){
  const idx = findManualIndexById(id);
  if(idx < 0) return;

  const dateEl = document.getElementById(`mn_date_${id}`);
  const timeEl = document.getElementById(`mn_time_${id}`);
  const dateVal = dateEl?.value;
  const timeVal = timeEl?.value;
  if(!dateVal || !timeVal) return;

  const next = new Date(`${dateVal}T${timeVal}:00`);
  if(Number.isNaN(next.getTime())) return;

  const kill = new Date(next.getTime() - (state.manual[idx].hours * 3600 * 1000));
  state.manual[idx].lastKill = kill.toISOString();
  state.manual[idx].lastRestart = new Date().toISOString();
  saveState();
  renderAll();
}

/* ---------------------------
   Rendering (sorted lowest -> highest remaining)
----------------------------*/
function renderAll(){
  renderManual();
  renderScheduled();
}

function renderManual(){
  manualGrid.innerHTML = "";
  const now = new Date();

  const ordered = state.manual
    .map(b => ({ b, diff: getManualDiffMs(b, now) }))
    .sort((a, c) => (a.diff - c.diff) || a.b.name.localeCompare(c.b.name));

  ordered.forEach(({ b }) => {
    const next = getManualNextTime(b);
    const nextTxt = next ? formatClockPH(next) : "--:-- --";

    const id = b.id;
    const card = document.createElement("div");
    card.className = "card manual";

    card.innerHTML = `
      <div class="topRow">
        <div class="bossName">${escapeHtml(b.name)}</div>
        <div class="pill">${b.hours}h</div>
      </div>

      <div class="timer red" data-manual-timer="${escapeAttr(id)}">00:00:00</div>
      <div class="nextLine">NEXT: <span data-manual-next="${escapeAttr(id)}">${nextTxt}</span></div>

      <div class="controls">
        <div class="dateRow">
          <input class="input" id="mk_date_${escapeAttr(id)}" type="date" />
          <input class="input" id="mk_time_${escapeAttr(id)}" type="time" />
        </div>
        <button class="miniBtn" data-action="fillKill" data-id="${escapeAttr(id)}" title="Fill with now">üïí</button>
      </div>

      <div class="controls">
        <div class="dateRow">
          <input class="input" id="mn_date_${escapeAttr(id)}" type="date" />
          <input class="input" id="mn_time_${escapeAttr(id)}" type="time" />
        </div>
        <button class="miniBtn" data-action="fillNext" data-id="${escapeAttr(id)}" title="Fill with next">‚è±</button>
      </div>

      <div class="btnStack">
        <button class="stackBtn" data-action="killedNow" data-id="${escapeAttr(id)}">Killed Now</button>
        <button class="stackBtn" data-action="setKill" data-id="${escapeAttr(id)}">Set Kill</button>
        <button class="stackBtn" data-action="setNext" data-id="${escapeAttr(id)}">Set Next</button>
      </div>

      <div class="footer">
        <div>Last restart: ${b.lastRestart ? escapeHtml(formatShortPH(new Date(b.lastRestart))) : "--"}</div>
        <div class="muted">${b.lastKill ? "Kill set" : "No kill yet"}</div>
      </div>
    `;

    card.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-action]");
      if(!btn) return;
      const action = btn.dataset.action;
      const bossId = btn.dataset.id;

      if(action === "killedNow") manualKilledNow(bossId);
      if(action === "setKill") manualSetKill(bossId);
      if(action === "setNext") manualSetNext(bossId);

      if(action === "fillKill"){
        const now2 = new Date();
        const d = document.getElementById(`mk_date_${bossId}`);
        const t = document.getElementById(`mk_time_${bossId}`);
        if(d) d.value = now2.toISOString().slice(0,10);
        if(t) t.value = `${pad(now2.getHours())}:${pad(now2.getMinutes())}`;
      }

      if(action === "fillNext"){
        const idx = findManualIndexById(bossId);
        const nxt = (idx >= 0) ? (getManualNextTime(state.manual[idx]) || new Date()) : new Date();
        const d = document.getElementById(`mn_date_${bossId}`);
        const t = document.getElementById(`mn_time_${bossId}`);
        if(d) d.value = nxt.toISOString().slice(0,10);
        if(t) t.value = `${pad(nxt.getHours())}:${pad(nxt.getMinutes())}`;
      }
    });

    manualGrid.appendChild(card);
  });
}

function renderScheduled(){
  scheduledGrid.innerHTML = "";
  const now = new Date();

  const ordered = state.scheduled
    .map(b => ({ b, diff: getScheduledDiffMs(b, now) }))
    .sort((a, c) => (a.diff - c.diff) || a.b.name.localeCompare(c.b.name));

  ordered.forEach(({ b }) => {
    const next = nextOccurrenceFromRule(b.rule, new Date());
    const nextTxt = next ? formatClockPH(next) : "--:-- --";

    const id = b.id;
    const card = document.createElement("div");
    card.className = "card scheduled";

    card.innerHTML = `
      <div class="topRow">
        <div class="bossName">${escapeHtml(b.name)}</div>
        <div class="pill">Scheduled</div>
      </div>

      <div class="timer red" data-sched-timer="${escapeAttr(id)}">00:00:00</div>
      <div class="nextLine">NEXT: <span data-sched-next="${escapeAttr(id)}">${nextTxt}</span></div>

      <div class="controls">
        <input class="input" id="sr_${escapeAttr(id)}" value="${escapeAttr(b.rule)}" />
        <button class="miniBtn" data-action="saveRule" data-id="${escapeAttr(id)}">Save</button>
      </div>

      <div class="btnStack">
        <button class="stackBtn" data-action="setNextNow" data-id="${escapeAttr(id)}">Set Next</button>
      </div>

      <div class="footer">
        <div>Schedule: ${escapeHtml(b.rule)}</div>
        <div class="muted">PH time</div>
      </div>
    `;

    card.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-action]");
      if(!btn) return;

      const action = btn.dataset.action;
      const bossId = btn.dataset.id;
      const idx = findScheduledIndexById(bossId);
      if(idx < 0) return;

      if(action === "saveRule"){
        const inp = document.getElementById(`sr_${bossId}`);
        const val = inp?.value.trim();
        if(!val) return;
        state.scheduled[idx].rule = val;
        saveState();
        renderAll();
      }

      if(action === "setNextNow"){
        const now2 = new Date();
        now2.setSeconds(0,0);
        now2.setMinutes(now2.getMinutes() + 5);
        const dowKey = Object.keys(DOW).find(k => DOW[k] === now2.getDay()) || "mon";
        const hh = pad(now2.getHours());
        const mm = pad(now2.getMinutes());
        state.scheduled[idx].rule = `${dowKey} ${hh}:${mm}`;
        saveState();
        renderAll();
      }
    });

    scheduledGrid.appendChild(card);
  });
}

/* ---------------------------
   Live ticking
----------------------------*/
function setTimerColor(el, diffMs){
  el.classList.remove("green","red");
  el.classList.add(diffMs > 0 ? "green" : "red");
}

function tick(){
  const now = new Date();

  // Update banner (PH time display)
  updateNextBossBanner(now);

  // Manual timers
  document.querySelectorAll("[data-manual-timer]").forEach(el => {
    const id = el.getAttribute("data-manual-timer");
    const idx = findManualIndexById(id);
    if(idx < 0) return;

    const b = state.manual[idx];
    const next = getManualNextTime(b);

    if(!next){
      el.textContent = "00:00:00";
      setTimerColor(el, -1);
      return;
    }

    const diff = next - now;
    el.textContent = msToClock(diff);
    setTimerColor(el, diff);

    // Auto reset after 30s if expired
    scheduleAutoResetIfExpired(b, diff);
  });

  document.querySelectorAll("[data-manual-next]").forEach(el => {
    const id = el.getAttribute("data-manual-next");
    const idx = findManualIndexById(id);
    if(idx < 0) return;

    const next = getManualNextTime(state.manual[idx]);
    el.textContent = next ? formatClockPH(next) : "--:-- --";
  });

  // Scheduled timers
  document.querySelectorAll("[data-sched-timer]").forEach(el => {
    const id = el.getAttribute("data-sched-timer");
    const idx = findScheduledIndexById(id);
    if(idx < 0) return;

    const b = state.scheduled[idx];
    const next = nextOccurrenceFromRule(b.rule, now);

    if(!next){
      el.textContent = "00:00:00";
      setTimerColor(el, -1);
      return;
    }

    const diff = next - now;
    el.textContent = msToClock(diff);
    setTimerColor(el, diff);
  });

  document.querySelectorAll("[data-sched-next]").forEach(el => {
    const id = el.getAttribute("data-sched-next");
    const idx = findScheduledIndexById(id);
    if(idx < 0) return;

    const next = nextOccurrenceFromRule(state.scheduled[idx].rule, now);
    el.textContent = next ? formatClockPH(next) : "--:-- --";
  });
}

function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function escapeAttr(str){
  return escapeHtml(str).replaceAll("\n"," ");
}

/* boot */
renderAll();
tick();
setInterval(tick, 250);
</script>
</body>
</html>
